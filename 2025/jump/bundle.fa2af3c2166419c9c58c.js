"use strict";(self.webpackChunkjump_game=self.webpackChunkjump_game||[]).push([[98],{3098:(t,e,s)=>{s.d(e,{WebGPURenderer:()=>Mt});var i=s(8507),r=s(9313),n=s(341),o=s(5611),a=s(4459),h=s(4e3),c=s(2067),l=s(6665),u=s(8475),p=s(5811);class d{constructor(){this.t=0}contextChange(t){const e=new p.k({uTransformMatrix:{value:new r.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}});this.t=t.limits.maxBatchableTextures;const s=(0,o.v)({name:"graphics",bits:[a.F,(0,h.o)(this.t),c.p,l.b]});this.shader=new u.M({gpuProgram:s,resources:{localUniforms:e}})}execute(t,e){const s=e.context,i=s.customShader||this.shader,r=t.renderer,o=r.graphicsContext,{batcher:a,instructions:h}=o.getContextRenderData(s),c=r.encoder;c.setGeometry(a.geometry,i.gpuProgram);const l=r.globalUniforms.bindGroup;c.setBindGroup(0,l,i.gpuProgram);const u=r.renderPipes.uniformBatch.getUniformBindGroup(i.resources.localUniforms,!0);c.setBindGroup(2,u,i.gpuProgram);const p=h.instructions;let d=null;for(let e=0;e<h.instructionSize;e++){const s=p[e];if(s.topology!==d&&(d=s.topology,c.setPipelineFromGeometryProgramAndState(a.geometry,i.gpuProgram,t.state,s.topology)),i.groups[1]=s.bindGroup,!s.gpuBindGroup){const t=s.textures;s.bindGroup=(0,n.w)(t.textures,t.count,this.t),s.gpuBindGroup=r.bindGroup.getBindGroup(s.bindGroup,i.gpuProgram,1)}c.setBindGroup(1,s.bindGroup,i.gpuProgram),c.renderPassEncoder.drawIndexed(s.size,1,s.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}d.extension={type:[i.Ag.WebGPUPipesAdaptor],name:"graphics"};var f=s(3391),m=s(5589),g=s(268);class y{init(){const t=(0,o.v)({name:"mesh",bits:[c.Ls,f.R,l.b]});this.m=new u.M({gpuProgram:t,resources:{uTexture:m.g.EMPTY.P,uSampler:m.g.EMPTY.P.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new r.u}}}})}execute(t,e){const s=t.renderer;let i=e.m;if(i){if(!i.gpuProgram)return void(0,g.R)("Mesh shader has no gpuProgram",e.shader)}else i=this.m,i.groups[2]=s.texture.getTextureBindGroup(e.texture);const r=i.gpuProgram;if(r.autoAssignGlobalUniforms&&(i.groups[0]=s.globalUniforms.bindGroup),r.autoAssignLocalUniforms){const e=t.localUniforms;i.groups[1]=s.renderPipes.uniformBatch.getUniformBindGroup(e,!0)}s.encoder.draw({geometry:e.G,shader:i,state:e.state})}destroy(){this.m.destroy(!0),this.m=null}}y.extension={type:[i.Ag.WebGPUPipesAdaptor],name:"mesh"};var b=s(7547);const x=b.U.for2d();class v{start(t,e,s){const i=t.renderer,r=i.encoder,n=s.gpuProgram;this.m=s,this.G=e,r.setGeometry(e,n),x.blendMode="normal",i.pipeline.getPipeline(e,n,x);const o=i.globalUniforms.bindGroup;r.resetBindGroup(1),r.setBindGroup(0,o,n)}execute(t,e){const s=this.m.gpuProgram,i=t.renderer,r=i.encoder;if(!e.bindGroup){const t=e.textures;e.bindGroup=(0,n.w)(t.textures,t.count,i.limits.maxBatchableTextures)}x.blendMode=e.blendMode;const o=i.bindGroup.getBindGroup(e.bindGroup,s,1),a=i.pipeline.getPipeline(this.G,s,x,e.topology);e.bindGroup.B(i.textureGC.count),r.setPipeline(a),r.renderPassEncoder.setBindGroup(1,o),r.renderPassEncoder.drawIndexed(e.size,1,e.start)}}v.extension={type:[i.Ag.WebGPUPipesAdaptor],name:"batch"};var w=s(800),P=s(1662),F=s(5099);class z{constructor(t){this.O=Object.create(null),this.C=t,this.C.renderableGC.addManagedHash(this,"_hash")}contextChange(t){this._=t}getBindGroup(t,e,s){return t.j(),this.O[t.A]||this.L(t,e,s)}L(t,e,s){const i=this._.device,r=e.layout[s],n=[],o=this.C;for(const e in r){const s=t.resources[e]??t.resources[r[e]];let i;if("uniformGroup"===s.H){const t=s;o.ubo.updateUniformGroup(t);const e=t.buffer;i={buffer:o.buffer.getGPUBuffer(e),offset:0,size:e.descriptor.size}}else if("buffer"===s.H){const t=s;i={buffer:o.buffer.getGPUBuffer(t),offset:0,size:t.descriptor.size}}else if("bufferResource"===s.H){const t=s;i={buffer:o.buffer.getGPUBuffer(t.buffer),offset:t.offset,size:t.size}}else if("textureSampler"===s.H){const t=s;i=o.texture.getGpuSampler(t)}else if("textureSource"===s.H){const t=s;i=o.texture.getGpuSource(t).createView({})}n.push({binding:r[e],resource:i})}const a=o.shader.getProgramData(e).bindGroups[s],h=i.createBindGroup({layout:a,entries:n});return this.O[t.A]=h,h}destroy(){for(const t of Object.keys(this.O))this.O[t]=null;this.O=null,this.C=null}}z.extension={type:[i.Ag.WebGPUSystem],name:"bindGroup"};var M=s(6736);class G{constructor(t){this.I=Object.create(null),this.V=[],t.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(t){this._=t}getGPUBuffer(t){return this.I[t.uid]||this.createGPUBuffer(t)}updateBuffer(t){const e=this.I[t.uid]||this.createGPUBuffer(t),s=t.data;return t.$&&s&&(t.$=0,this._.device.queue.writeBuffer(e,0,s.buffer,0,(t.D||s.byteLength)+3&-4)),e}destroyAll(){for(const t in this.I)this.I[t].destroy();this.I={}}createGPUBuffer(t){this.I[t.uid]||(t.on("update",this.updateBuffer,this),t.on("change",this.onBufferChange,this),t.on("destroy",this.onBufferDestroy,this),this.V.push(t));const e=this._.device.createBuffer(t.descriptor);return t.$=0,t.data&&((0,M.W)(t.data.buffer,e.getMappedRange()),e.unmap()),this.I[t.uid]=e,e}onBufferChange(t){this.I[t.uid].destroy(),t.$=0,this.I[t.uid]=this.createGPUBuffer(t)}onBufferDestroy(t){this.V.splice(this.V.indexOf(t),1),this.J(t)}destroy(){this.V.forEach(t=>this.J(t)),this.V=null,this.I=null}J(t){this.I[t.uid].destroy(),t.off("update",this.updateBuffer,this),t.off("change",this.onBufferChange,this),t.off("destroy",this.onBufferDestroy,this),this.I[t.uid]=null}}G.extension={type:[i.Ag.WebGPUSystem],name:"buffer"};class U{constructor(t){this.Y=15,this.C=t}setMask(t){this.Y!==t&&(this.Y=t,this.C.pipeline.setColorMask(t))}destroy(){this.C=null,this.Y=null}}U.extension={type:[i.Ag.WebGPUSystem],name:"colorMask"};var B=s(1761);class O{constructor(t){this.C=t}async init(t){return this.Z||(this.Z=(t.gpu?Promise.resolve(t.gpu):this.tt(t)).then(t=>{this.gpu=t,this.C.runners.contextChange.emit(this.gpu)})),this.Z}contextChange(t){this.C.gpu=t}async tt(t){const e=await B.e.get().getNavigator().gpu.requestAdapter({powerPreference:t.powerPreference,forceFallbackAdapter:t.forceFallbackAdapter}),s=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(t=>e.features.has(t)),i=await e.requestDevice({requiredFeatures:s});return{adapter:e,device:i}}destroy(){this.gpu=null,this.C=null}}O.extension={type:[i.Ag.WebGPUSystem],name:"device"},O.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class T{constructor(t){this.et=Object.create(null),this.st=Object.create(null),this.C=t}renderStart(){this.commandFinished=new Promise(t=>{this.it=t}),this.commandEncoder=this.C.gpu.device.createCommandEncoder()}beginRenderPass(t){this.endRenderPass(),this.rt(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(t.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(t){this.renderPassEncoder.setViewport(t.x,t.y,t.width,t.height,0,1)}setPipelineFromGeometryProgramAndState(t,e,s,i){const r=this.C.pipeline.getPipeline(t,e,s,i);this.setPipeline(r)}setPipeline(t){this.nt!==t&&(this.nt=t,this.renderPassEncoder.setPipeline(t))}ot(t,e){this.st[t]!==e&&(this.st[t]=e,this.renderPassEncoder.setVertexBuffer(t,this.C.buffer.updateBuffer(e)))}ht(t){if(this.ct===t)return;this.ct=t;const e=2===t.data.BYTES_PER_ELEMENT?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this.C.buffer.updateBuffer(t),e)}resetBindGroup(t){this.et[t]=null}setBindGroup(t,e,s){if(this.et[t]===e)return;this.et[t]=e,e.B(this.C.textureGC.count);const i=this.C.bindGroup.getBindGroup(e,s,t);this.renderPassEncoder.setBindGroup(t,i)}setGeometry(t,e){const s=this.C.pipeline.getBufferNamesToBind(t,e);for(const e in s)this.ot(parseInt(e,10),t.attributes[s[e]].buffer);t.indexBuffer&&this.ht(t.indexBuffer)}lt(t,e){for(const s in t.groups){const i=t.groups[s];e||this.ut(i),this.setBindGroup(s,i,t.gpuProgram)}}ut(t){for(const e in t.resources){const s=t.resources[e];s.isUniformGroup&&this.C.ubo.updateUniformGroup(s)}}draw(t){const{geometry:e,shader:s,state:i,topology:r,size:n,start:o,instanceCount:a,skipSync:h}=t;this.setPipelineFromGeometryProgramAndState(e,s.gpuProgram,i,r),this.setGeometry(e,s.gpuProgram),this.lt(s,h),e.indexBuffer?this.renderPassEncoder.drawIndexed(n||e.indexBuffer.data.length,a??e.instanceCount,o||0):this.renderPassEncoder.draw(n||e.getSize(),a??e.instanceCount,o||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._.device.queue.submit([this.commandEncoder.finish()]),this.it(),this.commandEncoder=null}restoreRenderPass(){const t=this.C.renderTarget.adaptor.getDescriptor(this.C.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(t);const e=this.nt,s={...this.st},i=this.ct,r={...this.et};this.rt();const n=this.C.renderTarget.viewport;this.renderPassEncoder.setViewport(n.x,n.y,n.width,n.height,0,1),this.setPipeline(e);for(const t in s)this.ot(t,s[t]);for(const t in r)this.setBindGroup(t,r[t],null);this.ht(i)}rt(){for(let t=0;t<16;t++)this.et[t]=null,this.st[t]=null;this.ct=null,this.nt=null}destroy(){this.C=null,this._=null,this.et=null,this.st=null,this.ct=null,this.nt=null}contextChange(t){this._=t}}T.extension={type:[i.Ag.WebGPUSystem],name:"encoder",priority:1};class k{constructor(t){this.C=t}contextChange(){this.maxTextures=this.C.device.gpu.device.limits.maxSampledTexturesPerShaderStage,this.maxBatchableTextures=this.maxTextures}destroy(){}}k.extension={type:[i.Ag.WebGPUSystem],name:"limits"};var C=s(1957);class _{constructor(t){this.dt=Object.create(null),this.C=t,t.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(t){let e=this.dt[t.uid];e||(e=this.dt[t.uid]={stencilMode:C.K.DISABLED,stencilReference:0}),this.ft=t,this.setStencilMode(e.stencilMode,e.stencilReference)}setStencilMode(t,e){const s=this.dt[this.ft.uid];s.stencilMode=t,s.stencilReference=e;const i=this.C;i.pipeline.setStencilMode(t),i.encoder.renderPassEncoder.setStencilReference(e)}destroy(){this.C.renderTarget.onRenderTargetChange.remove(this),this.C=null,this.ft=null,this.dt=null}}_.extension={type:[i.Ag.WebGPUSystem],name:"stencil"};var S=s(7047);const j={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function A(t){const e=t.map(t=>({data:t,offset:0,size:0}));let s=0;for(let t=0;t<e.length;t++){const i=e[t];let r=j[i.data.type].size;const n=j[i.data.type].align;if(!j[i.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${i.data.type}`);i.data.size>1&&(r=Math.max(r,n)*i.data.size),s=Math.ceil(s/n)*n,i.size=r,i.offset=s,s+=r}return s=16*Math.ceil(s/16),{uboElements:e,size:s}}var L=s(6423),R=s(1266);function H(t,e){const{size:s,align:i}=j[t.data.type],r=(i-s)/4,n=t.data.type.indexOf("i32")>=0?"dataInt32":"data";return`\n         v = uv.${t.data.name};\n         ${0!==e?`offset += ${e};`:""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${t.data.size*(s/4)}; i++)\n         {\n             for(var j = 0; j < ${s/4}; j++)\n             {\n                 ${n}[arrayOffset++] = v[t++];\n             }\n             ${0!==r?`arrayOffset += ${r};`:""}\n         }\n     `}function W(t){return(0,L.E)(t,"uboWgsl",H,R.o)}class I extends S.W{constructor(){super({createUboElements:A,generateUboSync:W})}}I.extension={type:[i.Ag.WebGPUSystem],name:"ubo"};var V=s(949),$=s(581),E=s(1132);class D{constructor({minUniformOffsetAlignment:t}){this.gt=256,this.byteIndex=0,this.gt=t,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(t){if(t>this.gt/4)throw new Error("UniformBufferBatch: array is too large: "+4*t);const e=this.byteIndex;let s=e+4*t;if(s=Math.ceil(s/this.gt)*this.gt,s>4*this.data.length)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=s,e}addGroup(t){const e=this.addEmptyGroup(t.length);for(let s=0;s<t.length;s++)this.data[e/4+s]=t[s];return e}destroy(){this.data=null}}var q=s(3513);const K=128;class N{constructor(t){this.yt=Object.create(null),this.bt=[],this.xt=[],this.vt=[],this.C=t,this.C.renderableGC.addManagedHash(this,"_bindGroupHash"),this.wt=new D({minUniformOffsetAlignment:K});for(let t=0;t<2;t++){let e=E.S.UNIFORM|E.S.COPY_DST;0===t&&(e|=E.S.COPY_SRC),this.bt.push(new V.h({data:this.wt.data,usage:e}))}}renderEnd(){this.Pt(),this.Ft()}Ft(){for(const t in this.yt)this.yt[t]=null;this.wt.clear()}getUniformBindGroup(t,e){if(!e&&this.yt[t.uid])return this.yt[t.uid];this.C.ubo.ensureUniformGroup(t);const s=t.buffer.data,i=this.wt.addEmptyGroup(s.length);return this.C.ubo.syncUniformGroup(t,this.wt.data,i/4),this.yt[t.uid]=this.zt(i/K),this.yt[t.uid]}getUboResource(t){this.C.ubo.updateUniformGroup(t);const e=t.buffer.data,s=this.wt.addGroup(e);return this.Mt(s/K)}getArrayBindGroup(t){const e=this.wt.addGroup(t);return this.zt(e/K)}getArrayBufferResource(t){const e=this.wt.addGroup(t)/K;return this.Mt(e)}Mt(t){if(!this.vt[t]){const e=this.bt[t%2];this.vt[t]=new $.d({buffer:e,offset:256*(t/2|0),size:K})}return this.vt[t]}zt(t){if(!this.xt[t]){const e=new q.T({0:this.Mt(t)});this.xt[t]=e}return this.xt[t]}Pt(){const t=this.C.buffer,e=this.bt[0];e.update(this.wt.byteIndex),t.updateBuffer(e);const s=this.C.gpu.device.createCommandEncoder();for(let i=1;i<this.bt.length;i++){const r=this.bt[i];s.copyBufferToBuffer(t.getGPUBuffer(e),K,t.getGPUBuffer(r),0,this.wt.byteIndex)}this.C.gpu.device.queue.submit([s.finish()])}destroy(){for(let t=0;t<this.xt.length;t++)this.xt[t]?.destroy();this.xt=null,this.yt=null;for(let t=0;t<this.bt.length;t++)this.bt[t].destroy();this.bt=null;for(let t=0;t<this.vt.length;t++)this.vt[t].destroy();this.vt=null,this.wt.destroy(),this.yt=null,this.C=null}}N.extension={type:[i.Ag.WebGPUPipes],name:"uniformBatch"};var X=s(7084),J=s(7952),Q=s(1172);const Y={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};class Z{constructor(t){this.Gt=Object.create(null),this.Ut=Object.create(null),this.Bt=Object.create(null),this.Ot=Object.create(null),this.Tt=Object.create(null),this.kt=15,this.Ct=1,this.C=t}contextChange(t){this._=t,this.setStencilMode(C.K.DISABLED),this._t()}setMultisampleCount(t){this.Ct!==t&&(this.Ct=t,this._t())}setRenderTarget(t){this.Ct=t.msaaSamples,this.St=t.descriptor.depthStencilAttachment?1:0,this._t()}setColorMask(t){this.kt!==t&&(this.kt=t,this._t())}setStencilMode(t){this.jt!==t&&(this.jt=t,this.At=Q.g[t],this._t())}setPipeline(t,e,s,i){const r=this.getPipeline(t,e,s);i.setPipeline(r)}getPipeline(t,e,s,i){t.Lt||((0,X.q)(t,e.attributeData),this.Rt(t)),i||(i=t.topology);const r=function(t,e,s,i,r){return t<<24|e<<16|s<<10|i<<5|r}(t.Lt,e.Lt,s.data,s.Ht,Y[i]);return this.Ot[r]||(this.Ot[r]=this.Wt(t,e,s,i)),this.Ot[r]}Wt(t,e,s,i){const r=this._.device,n=this.It(t,e),o=this.C.state.getColorTargets(s);o[0].writeMask=this.jt===C.K.RENDERING_MASK_ADD?0:this.kt;const a=this.C.shader.getProgramData(e).pipeline,h={vertex:{module:this.Vt(e.vertex.source),entryPoint:e.vertex.entryPoint,buffers:n},fragment:{module:this.Vt(e.fragment.source),entryPoint:e.fragment.entryPoint,targets:o},primitive:{topology:i,cullMode:s.cullMode},layout:a,multisample:{count:this.Ct},label:"PIXI Pipeline"};return this.St&&(h.depthStencil={...this.At,format:"depth24plus-stencil8",depthWriteEnabled:s.depthTest,depthCompare:s.depthTest?"less":"always"}),r.createRenderPipeline(h)}Vt(t){return this.Gt[t]||this.$t(t)}$t(t){const e=this._.device;return this.Gt[t]=e.createShaderModule({code:t}),this.Gt[t]}Rt(t){const e=[];let s=0;const i=Object.keys(t.attributes).sort();for(let r=0;r<i.length;r++){const n=t.attributes[i[r]];e[s++]=n.offset,e[s++]=n.format,e[s++]=n.stride,e[s++]=n.instance}const r=e.join("|");return t.Lt=(0,J.X)(r,"geometry"),t.Lt}Et(t){const e=[];let s=0;const i=Object.keys(t.attributeData).sort();for(let r=0;r<i.length;r++){const n=t.attributeData[i[r]];e[s++]=n.location}const r=e.join("|");return t.Dt=(0,J.X)(r,"programAttributes"),t.Dt}getBufferNamesToBind(t,e){const s=t.Lt<<16|e.Dt;if(this.Bt[s])return this.Bt[s];const i=this.It(t,e),r=Object.create(null),n=e.attributeData;for(let t=0;t<i.length;t++){const e=Object.values(i[t].attributes)[0].shaderLocation;for(const s in n)if(n[s].location===e){r[t]=s;break}}return this.Bt[s]=r,r}It(t,e){e.Dt||this.Et(e);const s=t.Lt<<16|e.Dt;if(this.Ut[s])return this.Ut[s];const i=[];return t.buffers.forEach(s=>{const r={arrayStride:0,stepMode:"vertex",attributes:[]},n=r.attributes;for(const i in e.attributeData){const o=t.attributes[i];1!==(o.divisor??1)&&(0,g.R)(`Attribute ${i} has an invalid divisor value of '${o.divisor}'. WebGPU only supports a divisor value of 1`),o.buffer===s&&(r.arrayStride=o.stride,r.stepMode=o.instance?"instance":"vertex",n.push({shaderLocation:e.attributeData[i].location,offset:o.offset,format:o.format}))}n.length&&i.push(r)}),this.Ut[s]=i,i}_t(){const t=(e=this.jt,s=this.Ct,this.kt<<6|e<<3|this.St<<1|s);var e,s;this.Tt[t]||(this.Tt[t]=Object.create(null)),this.Ot=this.Tt[t]}destroy(){this.C=null,this.Ut=null}}Z.extension={type:[i.Ag.WebGPUSystem],name:"pipeline"};var tt=s(7238),et=s(1257),st=s(4884),it=s(583);class rt{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class nt{init(t,e){this.C=t,this.qt=e}copyToTexture(t,e,s,i,r){const n=this.C,o=this.Kt(t),a=n.texture.getGpuSource(e.source);return n.encoder.commandEncoder.copyTextureToTexture({texture:o,origin:s},{texture:a,origin:r},i),e}startRenderPass(t,e=!0,s,i){const r=this.qt.getGpuRenderTarget(t),n=this.getDescriptor(t,e,s);r.descriptor=n,this.C.pipeline.setRenderTarget(r),this.C.encoder.beginRenderPass(r),this.C.encoder.setViewport(i)}finishRenderPass(){this.C.encoder.endRenderPass()}Kt(t){const e=this.qt.getGpuRenderTarget(t);return e.contexts[0]?e.contexts[0].getCurrentTexture():this.C.texture.getGpuSource(t.colorTextures[0].source)}getDescriptor(t,e,s){"boolean"==typeof e&&(e=e?et.u.ALL:et.u.NONE);const i=this.qt,r=i.getGpuRenderTarget(t),n=t.colorTextures.map((t,n)=>{const o=r.contexts[n];let a,h;a=o?o.getCurrentTexture().createView():this.C.texture.getGpuSource(t).createView({mipLevelCount:1}),r.msaaTextures[n]&&(h=a,a=this.C.texture.getTextureView(r.msaaTextures[n]));const c=e&et.u.COLOR?"clear":"load";return s??(s=i.defaultClearColor),{view:a,resolveTarget:h,clearValue:s,storeOp:"store",loadOp:c}});let o;if(!t.stencil&&!t.depth||t.depthStencilTexture||(t.ensureDepthStencilTexture(),t.depthStencilTexture.source.sampleCount=r.msaa?4:1),t.depthStencilTexture){const s=e&et.u.STENCIL?"clear":"load",i=e&et.u.DEPTH?"clear":"load";o={view:this.C.texture.getGpuSource(t.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:s,depthClearValue:1,depthLoadOp:i,depthStoreOp:"store"}}return{colorAttachments:n,depthStencilAttachment:o}}clear(t,e=!0,s,i){if(!e)return;const{gpu:r,encoder:n}=this.C,o=r.device;if(null===n.commandEncoder){const r=o.createCommandEncoder(),n=this.getDescriptor(t,e,s),a=r.beginRenderPass(n);a.setViewport(i.x,i.y,i.width,i.height,0,1),a.end();const h=r.finish();o.queue.submit([h])}else this.startRenderPass(t,e,s,i)}initGpuRenderTarget(t){t.isRoot=!0;const e=new rt;return t.colorTextures.forEach((t,s)=>{if(t instanceof st.q){const i=t.resource.getContext("webgpu"),r=t.transparent?"premultiplied":"opaque";try{i.configure({device:this.C.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:r})}catch(t){console.error(t)}e.contexts[s]=i}if(e.msaa=t.source.antialias,t.source.antialias){const t=new it.v({width:0,height:0,sampleCount:4});e.msaaTextures[s]=t}}),e.msaa&&(e.msaaSamples=4,t.depthStencilTexture&&(t.depthStencilTexture.source.sampleCount=4)),e}destroyGpuRenderTarget(t){t.contexts.forEach(t=>{t.unconfigure()}),t.msaaTextures.forEach(t=>{t.destroy()}),t.msaaTextures.length=0,t.contexts.length=0}ensureDepthStencilTexture(t){const e=this.qt.getGpuRenderTarget(t);t.depthStencilTexture&&e.msaa&&(t.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(t){const e=this.qt.getGpuRenderTarget(t);e.width=t.width,e.height=t.height,e.msaa&&t.colorTextures.forEach((t,s)=>{const i=e.msaaTextures[s];i?.resize(t.source.width,t.source.height,t.source.Nt)})}}class ot extends tt.l{constructor(t){super(t),this.adaptor=new nt,this.adaptor.init(t,this)}}ot.extension={type:[i.Ag.WebGPUSystem],name:"renderTarget"};class at{constructor(){this.Xt=Object.create(null)}contextChange(t){this._=t}getProgramData(t){return this.Xt[t.Lt]||this.Jt(t)}Jt(t){const e=this._.device,s=t.gpuLayout.map(t=>e.createBindGroupLayout({entries:t})),i={bindGroupLayouts:s};return this.Xt[t.Lt]={bindGroups:s,pipeline:e.createPipelineLayout(i)},this.Xt[t.Lt]}destroy(){this._=null,this.Xt=null}}at.extension={type:[i.Ag.WebGPUSystem],name:"shader"};const ht={normal:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},add:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},multiply:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},screen:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},overlay:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},none:{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},"normal-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},"add-npm":{alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},"screen-npm":{alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},erase:{alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}},min:{alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}},max:{alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}}};class ct{constructor(){this.defaultState=new b.U,this.defaultState.blend=!0}contextChange(t){this.gpu=t}getColorTargets(t){return[{format:"bgra8unorm",writeMask:0,blend:ht[t.blendMode]||ht.normal}]}destroy(){this.gpu=null}}ct.extension={type:[i.Ag.WebGPUSystem],name:"state"};var lt=s(7608);const ut={type:"image",upload(t,e,s){const i=t.resource,r=(0|t.pixelWidth)*(0|t.pixelHeight),n=i.byteLength/r;s.device.queue.writeTexture({texture:e},i,{offset:0,rowsPerImage:t.pixelHeight,bytesPerRow:t.pixelWidth*n},{width:t.pixelWidth,height:t.pixelHeight,depthOrArrayLayers:1})}},pt={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},dt={blockBytes:4,blockWidth:1,blockHeight:1},ft={type:"compressed",upload(t,e,s){let i=t.pixelWidth,r=t.pixelHeight;const n=pt[t.format]||dt;for(let o=0;o<t.resource.length;o++){const a=t.resource[o],h=Math.ceil(i/n.blockWidth)*n.blockBytes;s.device.queue.writeTexture({texture:e,mipLevel:o},a,{offset:0,bytesPerRow:h},{width:Math.ceil(i/n.blockWidth)*n.blockWidth,height:Math.ceil(r/n.blockHeight)*n.blockHeight,depthOrArrayLayers:1}),i=Math.max(i>>1,1),r=Math.max(r>>1,1)}}},mt={type:"image",upload(t,e,s){const i=t.resource;if(!i)return;if(globalThis.HTMLImageElement&&i instanceof HTMLImageElement){const e=B.e.get().createCanvas(i.width,i.height);e.getContext("2d").drawImage(i,0,0,i.width,i.height),t.resource=e,(0,g.R)("ImageSource: Image element passed, converting to canvas and replacing resource.")}const r=Math.min(e.width,t.resourceWidth||t.pixelWidth),n=Math.min(e.height,t.resourceHeight||t.pixelHeight),o="premultiply-alpha-on-upload"===t.alphaMode;s.device.queue.copyExternalImageToTexture({source:i},{texture:e,premultipliedAlpha:o},{width:r,height:n})}},gt={type:"video",upload(t,e,s){mt.upload(t,e,s)}};class yt{constructor(t){this.device=t,this.sampler=t.createSampler({minFilter:"linear"}),this.pipelines={}}Qt(t){let e=this.pipelines[t];return e||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:"\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "})),e=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:t}]}}),this.pipelines[t]=e),e}generateMipmap(t){const e=this.Qt(t.format);if("3d"===t.dimension||"1d"===t.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let s=t;const i=t.depthOrArrayLayers||1,r=t.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!r){const e={size:{width:Math.ceil(t.width/2),height:Math.ceil(t.height/2),depthOrArrayLayers:i},format:t.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:t.mipLevelCount-1};s=this.device.createTexture(e)}const n=this.device.createCommandEncoder({}),o=e.getBindGroupLayout(0);for(let a=0;a<i;++a){let i=t.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),h=r?1:0;for(let r=1;r<t.mipLevelCount;++r){const t=s.createView({baseMipLevel:h++,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),r=n.beginRenderPass({colorAttachments:[{view:t,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),c=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:this.sampler},{binding:1,resource:i}]});r.setPipeline(e),r.setBindGroup(0,c),r.draw(3,1,0,0),r.end(),i=t}}if(!r){const e={width:Math.ceil(t.width/2),height:Math.ceil(t.height/2),depthOrArrayLayers:i};for(let i=1;i<t.mipLevelCount;++i)n.copyTextureToTexture({texture:s,mipLevel:i-1},{texture:t,mipLevel:i},e),e.width=Math.ceil(e.width/2),e.height=Math.ceil(e.height/2)}return this.device.queue.submit([n.finish()]),r||s.destroy(),t}}class bt{constructor(t){this.managedTextures=[],this.Yt=Object.create(null),this.Zt=Object.create(null),this.yt=Object.create(null),this.te=Object.create(null),this.ee={image:mt,buffer:ut,video:gt,compressed:ft},this.C=t,t.renderableGC.addManagedHash(this,"_gpuSources"),t.renderableGC.addManagedHash(this,"_gpuSamplers"),t.renderableGC.addManagedHash(this,"_bindGroupHash"),t.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(t){this._=t}initSource(t){return this.Yt[t.uid]?this.Yt[t.uid]:this.se(t)}se(t){if(t.autoGenerateMipmaps){const e=Math.max(t.pixelWidth,t.pixelHeight);t.mipLevelCount=Math.floor(Math.log2(e))+1}let e=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;"compressed"!==t.uploadMethodId&&(e|=GPUTextureUsage.RENDER_ATTACHMENT,e|=GPUTextureUsage.COPY_SRC);const s=pt[t.format]||{blockBytes:4,blockWidth:1,blockHeight:1},i=Math.ceil(t.pixelWidth/s.blockWidth)*s.blockWidth,r=Math.ceil(t.pixelHeight/s.blockHeight)*s.blockHeight,n={label:t.label,size:{width:i,height:r},format:t.format,sampleCount:t.sampleCount,mipLevelCount:t.mipLevelCount,dimension:t.dimension,usage:e},o=this.Yt[t.uid]=this._.device.createTexture(n);return this.managedTextures.includes(t)||(t.on("update",this.onSourceUpdate,this),t.on("resize",this.onSourceResize,this),t.on("destroy",this.onSourceDestroy,this),t.on("unload",this.onSourceUnload,this),t.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(t)),this.onSourceUpdate(t),o}onSourceUpdate(t){const e=this.getGpuSource(t);e&&(this.ee[t.uploadMethodId]&&this.ee[t.uploadMethodId].upload(t,e,this._),t.autoGenerateMipmaps&&t.mipLevelCount>1&&this.onUpdateMipmaps(t))}onSourceUnload(t){const e=this.Yt[t.uid];e&&(this.Yt[t.uid]=null,e.destroy())}onUpdateMipmaps(t){this.ie||(this.ie=new yt(this._.device));const e=this.getGpuSource(t);this.ie.generateMipmap(e)}onSourceDestroy(t){t.off("update",this.onSourceUpdate,this),t.off("unload",this.onSourceUnload,this),t.off("destroy",this.onSourceDestroy,this),t.off("resize",this.onSourceResize,this),t.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(t),1),this.onSourceUnload(t)}onSourceResize(t){const e=this.Yt[t.uid];e?e.width===t.pixelWidth&&e.height===t.pixelHeight||(this.te[t.uid]=null,this.yt[t.uid]=null,this.onSourceUnload(t),this.initSource(t)):this.initSource(t)}re(t){return this.Zt[t.ne]=this._.device.createSampler(t),this.Zt[t.ne]}getGpuSampler(t){return this.Zt[t.ne]||this.re(t)}getGpuSource(t){return this.Yt[t.uid]||this.initSource(t)}getTextureBindGroup(t){return this.yt[t.uid]??this.oe(t)}oe(t){const e=t.source;return this.yt[t.uid]=new q.T({0:e,1:e.style,2:new p.k({uTextureMatrix:{type:"mat3x3<f32>",value:t.textureMatrix.mapCoord}})}),this.yt[t.uid]}getTextureView(t){const e=t.source;return this.te[e.uid]??this.ae(e)}ae(t){return this.te[t.uid]=this.getGpuSource(t).createView(),this.te[t.uid]}generateCanvas(t){const e=this.C,s=e.gpu.device.createCommandEncoder(),i=B.e.get().createCanvas();i.width=t.source.pixelWidth,i.height=t.source.pixelHeight;const r=i.getContext("webgpu");return r.configure({device:e.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:B.e.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),s.copyTextureToTexture({texture:e.texture.getGpuSource(t.source),origin:{x:0,y:0}},{texture:r.getCurrentTexture()},{width:i.width,height:i.height}),e.gpu.device.queue.submit([s.finish()]),i}getPixels(t){const e=this.generateCanvas(t),s=lt.N.getOptimalCanvasAndContext(e.width,e.height),i=s.context;i.drawImage(e,0,0);const{width:r,height:n}=e,o=i.getImageData(0,0,r,n),a=new Uint8ClampedArray(o.data.buffer);return lt.N.returnCanvasAndContext(s),{pixels:a,width:r,height:n}}destroy(){this.managedTextures.slice().forEach(t=>this.onSourceDestroy(t)),this.managedTextures=null;for(const t of Object.keys(this.yt)){const e=Number(t),s=this.yt[e];s?.destroy(),this.yt[e]=null}this._=null,this.ie=null,this.Yt=null,this.yt=null,this.te=null,this.Zt=null}}bt.extension={type:[i.Ag.WebGPUSystem],name:"texture"};const xt=[...P.i,I,T,O,k,G,bt,ot,at,ct,Z,U,_,z],vt=[...P.f,N],wt=[v,y,d],Pt=[],Ft=[],zt=[];i.XO.handleByNamedList(i.Ag.WebGPUSystem,Pt),i.XO.handleByNamedList(i.Ag.WebGPUPipes,Ft),i.XO.handleByNamedList(i.Ag.WebGPUPipesAdaptor,zt),i.XO.add(...xt,...vt,...wt);class Mt extends w.k{constructor(){super({name:"webgpu",type:F.W.WEBGPU,systems:Pt,renderPipes:Ft,renderPipeAdaptors:zt})}}}}]);