"use strict";(self.webpackChunkjump_game=self.webpackChunkjump_game||[]).push([[582],{2067:(t,e,n)=>{n.d(e,{Ls:()=>i,t:()=>s,mA:()=>r});const i={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},s={...i,vertex:{...i.vertex,header:i.vertex.header.replace("group(1)","group(2)")}},r={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},2206:(t,e,n)=>{var i=n(8507),s=n(2289),r=n(8422);class o extends r.K{constructor(t){super(),this.o=t,t.runners.resolutionChange.add(this)}resolutionChange(){const t=this.renderable;t.p&&t.onViewUpdate()}destroy(){const{canvasText:t}=this.o;t.getReferenceCount(this.currentKey)>0?t.decreaseReferenceCount(this.currentKey):this.texture&&t.returnTexture(this.texture),this.o.runners.resolutionChange.remove(this),this.o=null}}class a{constructor(t){this.o=t}validateRenderable(t){const e=this.C(t),n=t.styleKey;return e.currentKey!==n||t._}addRenderable(t,e){const n=this.C(t);if(t._){const e=t.p?this.o.resolution:t.resolution;n.currentKey===t.styleKey&&t.resolution===e||this.O(t),t._=!1,(0,s.s)(n,t)}this.o.renderPipes.batch.addToBatch(n,e)}updateRenderable(t){const e=this.C(t);e.D.updateElement(e)}O(t){const e=this.C(t);e.texture&&this.o.canvasText.decreaseReferenceCount(e.currentKey),t.$=t.p?this.o.resolution:t.resolution,e.texture=this.o.canvasText.getManagedTexture(t),e.currentKey=t.styleKey}C(t){return t.L[this.o.uid]||this.initGpuText(t)}initGpuText(t){const e=new o(this.o);return e.currentKey="--",e.renderable=t,e.transform=t.groupTransform,e.bounds={minX:0,maxX:1,minY:0,maxY:0},e.roundPixels=this.o.X|t.X,t.L[this.o.uid]=e,e}destroy(){this.o=null}}a.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"text"};var u=n(2437),l=n(218),h=n(4670),c=n(8291),f=n(2558),d=n(9492);class m{constructor(t){this.Y={},this.o=t}getTexture(t,e,n,i){"string"==typeof t&&((0,h.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),t={text:t,style:n,resolution:e}),t.style instanceof c.x||(t.style=new c.x(t.style)),t.textureStyle instanceof l.n||(t.textureStyle=new l.n(t.textureStyle)),"string"!=typeof t.text&&(t.text=t.text.toString());const{text:s,style:r,textureStyle:o}=t,a=t.resolution??this.o.resolution,{frame:u,canvasAndContext:m}=d.v.getCanvasAndContext({text:s,style:r,resolution:a}),p=(0,f.M)(m.canvas,u.width,u.height,a);if(o&&(p.source.style=o),r.trim&&(u.pad(r.padding),p.frame.copyFrom(u),p.frame.scale(1/a),p.updateUvs()),r.filters){const t=this.H(p,r.filters);return this.returnTexture(p),d.v.returnCanvasAndContext(m),t}return this.o.texture.initSource(p.j),d.v.returnCanvasAndContext(m),p}returnTexture(t){const e=t.source;e.resource=null,e.uploadMethodId="unknown",e.alphaMode="no-premultiply-alpha",u.W.returnTexture(t,!0)}renderTextToCanvas(){(0,h.t6)("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(t){t.$=t.p?this.o.resolution:t.resolution;const e=t.styleKey;if(this.Y[e])return this.q(e),this.Y[e].texture;const n=this.getTexture({text:t.text,style:t.style,resolution:t.$,textureStyle:t.textureStyle});return this.Y[e]={texture:n,usageCount:1},n}decreaseReferenceCount(t){const e=this.Y[t];e.usageCount--,0===e.usageCount&&(this.returnTexture(e.texture),this.Y[t]=null)}getReferenceCount(t){return this.Y[t]?.usageCount??0}q(t){this.Y[t].usageCount++}H(t,e){const n=this.o.renderTarget.renderTarget,i=this.o.filter.generateFilteredTexture({texture:t,filters:e});return this.o.renderTarget.bind(n,!1),i}destroy(){this.o=null;for(const t in this.Y)this.Y[t]&&this.returnTexture(this.Y[t].texture);this.Y=null}}m.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem,i.Ag.CanvasSystem],name:"canvasText"},i.XO.add(m),i.XO.add(a)},2289:(t,e,n)=>{n.d(e,{s:()=>s});var i=n(2048);function s(t,e){const{texture:n,bounds:s}=t,r=e.tt.J();(0,i.y)(s,e.et,n);const o=e.et.nt*r*2,a=e.et.it*r*2;s.minX-=r-o,s.minY-=r-a,s.maxX-=r-o,s.maxY-=r-a}},2558:(t,e,n)=>{n.d(e,{M:()=>r});var i=n(2437);const s=new(n(9636).c);function r(t,e,n,r){const o=s;o.minX=0,o.minY=0,o.maxX=t.width/r|0,o.maxY=t.height/r|0;const a=i.W.getOptimalTexture(o.width,o.height,r,!1);return a.source.uploadMethodId="image",a.source.resource=t,a.source.alphaMode="premultiply-alpha-on-upload",a.frame.width=e/r,a.frame.height=n/r,a.source.emit("update",a.source),a.updateUvs(),a}},2623:(t,e,n)=>{var i=n(8507),s=n(5589),r=n(2289),o=n(8422);class a extends o.K{constructor(t){super(),this.generatingTexture=!1,this.currentKey="--",this.o=t,t.runners.resolutionChange.add(this)}resolutionChange(){const t=this.renderable;t.p&&t.onViewUpdate()}destroy(){const{htmlText:t}=this.o;null===t.getReferenceCount(this.currentKey)?t.returnTexturePromise(this.texturePromise):t.decreaseReferenceCount(this.currentKey),this.o.runners.resolutionChange.remove(this),this.texturePromise=null,this.o=null}}class u{constructor(t){this.o=t}validateRenderable(t){const e=this.C(t),n=t.styleKey;return e.currentKey!==n}addRenderable(t,e){const n=this.C(t);if(t._){const e=t.p?this.o.resolution:t.resolution;n.currentKey===t.styleKey&&t.resolution===e||this.O(t).catch(t=>{console.error(t)}),t._=!1,(0,r.s)(n,t)}this.o.renderPipes.batch.addToBatch(n,e)}updateRenderable(t){const e=this.C(t);e.D.updateElement(e)}async O(t){t._=!1;const e=this.C(t);if(e.generatingTexture)return;const n=e.texturePromise;e.texturePromise=null,e.generatingTexture=!0,t.$=t.p?this.o.resolution:t.resolution;let i=this.o.htmlText.getTexturePromise(t);n&&(i=i.finally(()=>{this.o.htmlText.decreaseReferenceCount(e.currentKey),this.o.htmlText.returnTexturePromise(n)})),e.texturePromise=i,e.currentKey=t.styleKey,e.texture=await i;const s=t.renderGroup||t.parentRenderGroup;s&&(s.structureDidChange=!0),e.generatingTexture=!1,(0,r.s)(e,t)}C(t){return t.L[this.o.uid]||this.initGpuText(t)}initGpuText(t){const e=new a(this.o);return e.renderable=t,e.transform=t.groupTransform,e.texture=s.g.EMPTY,e.bounds={minX:0,maxX:1,minY:0,maxY:0},e.roundPixels=this.o.X|t.X,t.$=t.p?this.o.resolution:t.resolution,t.L[this.o.uid]=e,e}destroy(){this.o=null}}u.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"htmlText"};var l=n(7608),h=n(2437),c=n(5099),f=n(1761),d=n(268),m=n(8655),p=n(2558);const v="http://www.w3.org/2000/svg",g="http://www.w3.org/1999/xhtml";class x{constructor(){this.svgRoot=document.createElementNS(v,"svg"),this.foreignObject=document.createElementNS(v,"foreignObject"),this.domElement=document.createElementNS(g,"div"),this.styleElement=document.createElementNS(g,"style");const{foreignObject:t,svgRoot:e,styleElement:n,domElement:i}=this;t.setAttribute("width","10000"),t.setAttribute("height","10000"),t.style.overflow="hidden",e.appendChild(t),t.appendChild(n),t.appendChild(i),this.image=f.e.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}var y=n(1979);const b=new Map;let w;class T{constructor(t){this.Y={},this.o=t,this.st=t.type===c.W.WEBGPU}getTexture(t){return this.getTexturePromise(t)}getManagedTexture(t){const e=t.styleKey;if(this.Y[e])return this.q(e),this.Y[e].promise;const n=this.rt(t).then(t=>(this.Y[e].texture=t,t));return this.Y[e]={texture:null,promise:n,usageCount:1},n}getReferenceCount(t){return this.Y[t]?.usageCount??null}q(t){this.Y[t].usageCount++}decreaseReferenceCount(t){const e=this.Y[t];e&&(e.usageCount--,0===e.usageCount&&(e.texture?this.ot(e.texture):e.promise.then(t=>{e.texture=t,this.ot(e.texture)}).catch(()=>{(0,d.R)("HTMLTextSystem: Failed to clean texture")}),this.Y[t]=null))}getTexturePromise(t){return this.rt(t)}async rt(t){const{text:e,style:n,resolution:i,textureStyle:s}=t,r=m.Z.get(x),o=function(t,e){const n=e.fontFamily,i=[],s={},r=t.match(/font-family:([^;"\s]+)/g);function o(t){s[t]||(i.push(t),s[t]=!0)}if(Array.isArray(n))for(let t=0;t<n.length;t++)o(n[t]);else o(n);r&&r.forEach(t=>{o(t.split(":")[1].trim())});for(const t in e.tagStyles)o(e.tagStyles[t].fontFamily);return i}(e,n),a=await async function(t){const e=t.filter(t=>y.l.has(`${t}-and-url`)).map(t=>{if(!b.has(t)){const{entries:e}=y.l.get(`${t}-and-url`),n=[];e.forEach(e=>{const i=e.url,s=e.faces.map(t=>({weight:t.weight,style:t.style}));n.push(...s.map(e=>async function(t,e){const n=await async function(t){const e=await f.e.get().fetch(t),n=await e.blob(),i=new FileReader;return await new Promise((t,e)=>{i.onloadend=()=>t(i.result),i.onerror=e,i.readAsDataURL(n)})}(e);return`@font-face {\n        font-family: "${t.fontFamily}";\n        font-weight: ${t.fontWeight};\n        font-style: ${t.fontStyle};\n        src: url('${n}');\n    }`}({fontWeight:e.weight,fontStyle:e.style,fontFamily:t},i)))}),b.set(t,Promise.all(n).then(t=>t.join("\n")))}return b.get(t)});return(await Promise.all(e)).join("\n")}(o),u=function(t,e,n,i){i||(i=w||(w=new x));const{domElement:s,styleElement:r,svgRoot:o}=i;s.innerHTML=`<style>${e.cssStyle};</style><div style='padding:0'>${t}</div>`,s.setAttribute("style","transform-origin: top left; display: inline-block"),n&&(r.textContent=n),document.body.appendChild(o);const a=s.getBoundingClientRect();o.remove();const u=2*e.padding;return{width:a.width-u,height:a.height-u}}(e,n,a,r),h=Math.ceil(Math.ceil(Math.max(1,u.width)+2*n.padding)*i),c=Math.ceil(Math.ceil(Math.max(1,u.height)+2*n.padding)*i),d=r.image;d.width=2+(0|h),d.height=2+(0|c);const v=function(t,e,n,i,s){const{domElement:r,styleElement:o,svgRoot:a}=s;r.innerHTML=`<style>${e.cssStyle}</style><div style='padding:0;'>${t}</div>`,r.setAttribute("style",`transform: scale(${n});transform-origin: top left; display: inline-block`),o.textContent=i;const{width:u,height:l}=s.image;return a.setAttribute("width",u.toString()),a.setAttribute("height",l.toString()),(new XMLSerializer).serializeToString(a)}(e,n,i,a,r);await function(t,e,n){return new Promise(async i=>{n&&await new Promise(t=>setTimeout(t,100)),t.onload=()=>{i()},t.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`,t.crossOrigin="anonymous"})}(d,v,function(){const{userAgent:t}=f.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(t)}()&&o.length>0);const g=d;let T;this.st&&(T=function(t,e){const n=l.N.getOptimalCanvasAndContext(t.width,t.height,e),{context:i}=n;return i.clearRect(0,0,t.width,t.height),i.drawImage(t,0,0),n}(d,i));const C=(0,p.M)(T?T.canvas:g,d.width-2,d.height-2,i);return s&&(C.source.style=s),this.st&&(this.o.texture.initSource(C.source),l.N.returnCanvasAndContext(T)),m.Z.return(r),C}returnTexturePromise(t){t.then(t=>{this.ot(t)}).catch(()=>{(0,d.R)("HTMLTextSystem: Failed to clean texture")})}ot(t){h.W.returnTexture(t,!0),t.source.resource=null,t.source.uploadMethodId="unknown"}destroy(){this.o=null;for(const t in this.Y)this.Y[t]&&this.returnTexturePromise(this.Y[t].promise);this.Y=null}}T.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem,i.Ag.CanvasSystem],name:"htmlText"},i.XO.add(T),i.XO.add(u)},2760:(t,e,n)=>{function i(t,e,n){const i=(t>>24&255)/255;e[n++]=(255&t)/255*i,e[n++]=(t>>8&255)/255*i,e[n++]=(t>>16&255)/255*i,e[n++]=i}n.d(e,{V:()=>i})},3859:(t,e,n)=>{var i=n(8507);class s{constructor(t){this.o=t}push(t,e,n){this.o.renderPipes.batch.break(n),n.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:e,filterEffect:t})}pop(t,e,n){this.o.renderPipes.batch.break(n),n.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(t){"pushFilter"===t.action?this.o.filter.push(t):"popFilter"===t.action&&this.o.filter.pop()}destroy(){this.o=null}}s.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"filter"};var r=n(9113),o=n(3012),a=n(6554),u="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class l extends a.d{constructor(){super({gpuProgram:o.B.from({vertex:{source:u,entryPoint:"mainVertex"},fragment:{source:u,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:r.M.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}var h=n(9313),c=n(3513),f=n(6011),d=n(5811),m=n(5589),p=n(2437),v=n(5099),g=n(9636);const x=new h.u;var y=n(268);const b=new f.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class w{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new g.c,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class T{constructor(t){this.ut=0,this.lt=[],this.ht=new d.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this.ct=new c.T({}),this.renderer=t}get activeBackTexture(){return this.ft?.backTexture}push(t){const e=this.renderer,n=t.filterEffect.filters,i=this.dt();i.skip=!1,i.filters=n,i.container=t.container,i.outputRenderSurface=e.renderTarget.renderSurface;const s=e.renderTarget.renderTarget.colorTexture.source,r=s.resolution,o=s.antialias;if(n.every(t=>!t.enabled))return void(i.skip=!0);const a=i.bounds;if(this.vt(t,a),this.gt(i,e.renderTarget.rootViewPort,o,r,1),i.skip)return;const u=this.xt(),l=this.yt(r);let h=0,c=0;u&&(h=u.bounds.minX,c=u.bounds.minY),this.bt(i,h,c,l,s.width,s.height),this.wt(i,a,e,u)}generateFilteredTexture({texture:t,filters:e}){const n=this.dt();this.ft=n,n.skip=!1,n.filters=e;const i=t.source,s=i.resolution,r=i.antialias;if(e.every(t=>!t.enabled))return n.skip=!0,t;const o=n.bounds;if(o.addRect(t.frame),this.gt(n,o.rectangle,r,s,0),n.skip)return t;const a=s;this.bt(n,0,0,a,i.width,i.height),n.outputRenderSurface=p.W.getOptimalTexture(o.width,o.height,n.resolution,n.antialias),n.backTexture=m.g.EMPTY,n.inputTexture=t,this.renderer.renderTarget.finishRenderPass(),this.Tt(n,!0);const u=n.outputRenderSurface;return u.source.alphaMode="premultiplied-alpha",u}pop(){const t=this.renderer,e=this.Ct();e.skip||(t.globalUniforms.pop(),t.renderTarget.finishRenderPass(),this.ft=e,this.Tt(e,!1),e.blendRequired&&p.W.returnTexture(e.backTexture),p.W.returnTexture(e.inputTexture))}getBackTexture(t,e,n){const i=t.colorTexture.source.$,s=p.W.getOptimalTexture(e.width,e.height,i,!1);let r=e.minX,o=e.minY;n&&(r-=n.minX,o-=n.minY),r=Math.floor(r*i),o=Math.floor(o*i);const a=Math.ceil(e.width*i),u=Math.ceil(e.height*i);return this.renderer.renderTarget.copyToTexture(t,s,{x:r,y:o},{width:a,height:u},{x:0,y:0}),s}applyFilter(t,e,n,i){const s=this.renderer,r=this.ft,o=r.outputRenderSurface===n,a=s.renderTarget.rootRenderTarget.colorTexture.source.$,u=this.yt(a);let l=0,h=0;if(o){const t=this.Ft();l=t.x,h=t.y}this.Pt(e,n,r,l,h,u,o,i);const c=t.enabled?t:this.Mt();this.Rt(c,e,s)}calculateSpriteMatrix(t,e){const n=this.ft,i=t.set(n.inputTexture.j.width,0,0,n.inputTexture.j.height,n.bounds.minX,n.bounds.minY),s=e.worldTransform.copyTo(h.u.shared),r=e.renderGroup||e.parentRenderGroup;return r&&r.cacheToLocalTransform&&s.prepend(r.cacheToLocalTransform),s.invert(),i.prepend(s),i.scale(1/e.texture.orig.width,1/e.texture.orig.height),i.translate(e.anchor.x,e.anchor.y),i}destroy(){this.Ut?.destroy(!0),this.Ut=null}Mt(){return this.Ut??(this.Ut=new l),this.Ut}Rt(t,e,n){if(n.renderPipes.uniformBatch){const t=n.renderPipes.uniformBatch.getUboResource(this.ht);this.ct.setResource(t,0)}else this.ct.setResource(this.ht,0);this.ct.setResource(e.source,1),this.ct.setResource(e.source.style,2),t.groups[0]=this.ct,n.encoder.draw({geometry:b,shader:t,state:t.St,topology:"triangle-list"}),n.type===v.W.WEBGL&&n.renderTarget.finishRenderPass()}wt(t,e,n,i){if(t.backTexture=m.g.EMPTY,t.inputTexture=p.W.getOptimalTexture(e.width,e.height,t.resolution,t.antialias),t.blendRequired){n.renderTarget.finishRenderPass();const s=n.renderTarget.getRenderTarget(t.outputRenderSurface);t.backTexture=this.getBackTexture(s,e,i?.bounds)}n.renderTarget.bind(t.inputTexture,!0),n.globalUniforms.push({offset:e})}bt(t,e,n,i,s,r){const o=t.globalFrame;o.x=e*i,o.y=n*i,o.width=s*i,o.height=r*i}Pt(t,e,n,i,s,r,o,a){const u=this.ht.uniforms,l=u.uOutputFrame,h=u.uInputSize,c=u.uInputPixel,f=u.uInputClamp,d=u.uGlobalFrame,p=u.uOutputTexture;o?(l[0]=n.bounds.minX-i,l[1]=n.bounds.minY-s):(l[0]=0,l[1]=0),l[2]=t.frame.width,l[3]=t.frame.height,h[0]=t.source.width,h[1]=t.source.height,h[2]=1/h[0],h[3]=1/h[1],c[0]=t.source.pixelWidth,c[1]=t.source.pixelHeight,c[2]=1/c[0],c[3]=1/c[1],f[0]=.5*c[2],f[1]=.5*c[3],f[2]=t.frame.width*h[2]-.5*c[2],f[3]=t.frame.height*h[3]-.5*c[3];const v=this.renderer.renderTarget.rootRenderTarget.colorTexture;d[0]=i*r,d[1]=s*r,d[2]=v.source.width*r,d[3]=v.source.height*r,e instanceof m.g&&(e.source.resource=null);const g=this.renderer.renderTarget.getRenderTarget(e);this.renderer.renderTarget.bind(e,!!a),e instanceof m.g?(p[0]=e.frame.width,p[1]=e.frame.height):(p[0]=g.width,p[1]=g.height),p[2]=g.isRoot?-1:1,this.ht.update()}yt(t){let e=this.ut-1;for(;e>0&&this.lt[e].skip;)--e;return e>0&&this.lt[e].inputTexture?this.lt[e].inputTexture.source.$:t}Ft(){let t=0,e=0,n=this.ut;for(;n>0;){n--;const i=this.lt[n];if(!i.skip){t=i.bounds.minX,e=i.bounds.minY;break}}return{x:t,y:e}}vt(t,e){if(t.renderables?function(t,e){e.clear();const n=e.matrix;for(let n=0;n<t.length;n++){const i=t[n];if(i.globalDisplayStatus<7)continue;const s=i.renderGroup??i.parentRenderGroup;e.matrix=s?.isCachedAsTexture?x.copyFrom(s.textureOffsetInverseTransform).append(i.worldTransform):s?._t?x.copyFrom(s._t.inverseWorldTransform).append(i.groupTransform):i.worldTransform,e.addBounds(i.bounds)}e.matrix=n}(t.renderables,e):t.filterEffect.filterArea?(e.clear(),e.addRect(t.filterEffect.filterArea),e.applyMatrix(t.container.worldTransform)):t.container.getFastGlobalBounds(!0,e),t.container){const n=(t.container.renderGroup||t.container.parentRenderGroup).cacheToLocalTransform;n&&e.applyMatrix(n)}}Tt(t,e){const n=t.inputTexture,i=t.bounds,s=t.filters,r=t.firstEnabledIndex,o=t.lastEnabledIndex;if(this.ct.setResource(n.source.style,2),this.ct.setResource(t.backTexture.source,3),r===o)s[r].apply(this,n,t.outputRenderSurface,e);else{let n=t.inputTexture;const a=p.W.getOptimalTexture(i.width,i.height,n.source.$,!1);let u=a;for(let t=r;t<o;t++){const e=s[t];if(!e.enabled)continue;e.apply(this,n,u,!0);const i=n;n=u,u=i}s[o].apply(this,n,t.outputRenderSurface,e),p.W.returnTexture(a)}}gt(t,e,n,i,s){const r=this.renderer,o=t.bounds,a=t.filters;let u=1/0,l=0,h=!0,c=!1,f=!1,d=!0,m=-1,p=-1;for(let t=0;t<a.length;t++){const e=a[t];if(e.enabled){if(-1===m&&(m=t),p=t,u=Math.min(u,"inherit"===e.resolution?i:e.resolution),l+=e.padding,"off"===e.antialias?h=!1:"inherit"===e.antialias&&h&&(h=n),e.clipToViewport||(d=!1),!(e.compatibleRenderers&r.type)){f=!1;break}if(e.blendRequired&&!(r.backBuffer?.useBackBuffer??1)){(0,y.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),f=!1;break}f=!0,c||(c=e.blendRequired)}}f?(d&&o.fitBounds(0,e.width/i,0,e.height/i),o.scale(u).ceil().scale(1/u).pad((0|l)*s),o.isPositive?(t.antialias=h,t.resolution=u,t.blendRequired=c,t.firstEnabledIndex=m,t.lastEnabledIndex=p):t.skip=!0):t.skip=!0}Ct(){return this.ut--,this.lt[this.ut]}xt(){let t,e=this.ut-1;for(;e>0&&(e--,t=this.lt[e],t.skip););return t}dt(){let t=this.lt[this.ut];return t||(t=this.lt[this.ut]=new w),this.ut++,t}}T.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem],name:"filter"},i.XO.add(T),i.XO.add(s)},4732:(t,e,n)=>{var i=n(8507);class s{static init(t){Object.defineProperty(this,"resizeTo",{set(t){globalThis.removeEventListener("resize",this.queueResize),this.At=t,t&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this.At}}),this.queueResize=()=>{this.At&&(this.zt(),this.Ot=requestAnimationFrame(()=>this.resize()))},this.zt=()=>{this.Ot&&(cancelAnimationFrame(this.Ot),this.Ot=null)},this.resize=()=>{if(!this.At)return;let t,e;if(this.zt(),this.At===globalThis.window)t=globalThis.innerWidth,e=globalThis.innerHeight;else{const{clientWidth:n,clientHeight:i}=this.At;t=n,e=i}this.renderer.resize(t,e),this.render()},this.Ot=null,this.At=null,this.resizeTo=t.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this.zt(),this.zt=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}s.extension=i.Ag.Application;var r=n(4458),o=n(7309);class a{static init(t){t=Object.assign({autoStart:!0,sharedTicker:!1},t),Object.defineProperty(this,"ticker",{set(t){this.Vt&&this.Vt.remove(this.render,this),this.Vt=t,t&&t.add(this.render,this,r.d.LOW)},get(){return this.Vt}}),this.stop=()=>{this.Vt.stop()},this.start=()=>{this.Vt.start()},this.Vt=null,this.ticker=t.sharedTicker?o.R.shared:new o.R,t.autoStart&&this.start()}static destroy(){if(this.Vt){const t=this.Vt;this.ticker=null,t.destroy()}}}a.extension=i.Ag.Application,i.XO.add(s),i.XO.add(a)},5060:(t,e,n)=>{n.d(e,{u:()=>u});var i=n(949),s=n(1132),r=n(6011),o=n(4670);const a=class t extends r.V{constructor(...e){let n=e[0]??{};n instanceof Float32Array&&((0,o.t6)(o.lj,"use new MeshGeometry({ positions, uvs, indices }) instead"),n={positions:n,uvs:e[1],indices:e[2]}),n={...t.defaultOptions,...n};const r=n.positions||new Float32Array([0,0,1,0,1,1,0,1]);let a=n.uvs;a||(a=n.positions?new Float32Array(r.length):new Float32Array([0,0,1,0,1,1,0,1]));const u=n.indices||new Uint32Array([0,1,2,0,2,3]),l=n.shrinkBuffersToFit;super({attributes:{aPosition:{buffer:new i.h({data:r,label:"attribute-mesh-positions",shrinkToFit:l,usage:s.S.VERTEX|s.S.COPY_DST}),format:"float32x2",stride:8,offset:0},aUV:{buffer:new i.h({data:a,label:"attribute-mesh-uvs",shrinkToFit:l,usage:s.S.VERTEX|s.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new i.h({data:u,label:"index-mesh-buffer",shrinkToFit:l,usage:s.S.INDEX|s.S.COPY_DST}),topology:n.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(t){this.attributes.aPosition.buffer.data=t}get uvs(){return this.attributes.aUV.buffer.data}set uvs(t){this.attributes.aUV.buffer.data=t}get indices(){return this.indexBuffer.data}set indices(t){this.indexBuffer.data=t}};a.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let u=a},5285:(t,e,n)=>{var i=n(8507),s=n(9313),r=n(3513),o=n(5811),a=n(8639),u=n(2760),l=n(8734);class h{destroy(){}}class c{constructor(t,e){this.localUniforms=new o.k({uTransformMatrix:{value:new s.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new r.T({0:this.localUniforms}),this.renderer=t,this.Dt=e,this.Dt.init()}validateRenderable(t){const e=this.kt(t),n=e.batched,i=t.batched;if(e.batched=i,n!==i)return!0;if(i){const n=t.Bt;if(n.indices.length!==e.indexSize||n.positions.length!==e.vertexSize)return e.indexSize=n.indices.length,e.vertexSize=n.positions.length,!0;const i=this.Gt(t);return i.texture.uid!==t.$t.uid&&(i.It=-1),!i.D.checkAndUpdateTexture(i,t.$t)}return!1}addRenderable(t,e){const n=this.renderer.renderPipes.batch,i=this.kt(t);if(t.didViewUpdate&&(i.indexSize=t.Bt.indices?.length,i.vertexSize=t.Bt.positions?.length),i.batched){const i=this.Gt(t);i.setTexture(t.$t),i.geometry=t.Bt,n.addToBatch(i,e)}else n.break(e),e.add(t)}updateRenderable(t){if(t.batched){const e=this.Gt(t);e.setTexture(t.$t),e.geometry=t.Bt,e.D.updateElement(e)}}execute(t){if(!t.isRenderable)return;t.state.blendMode=(0,a.i)(t.groupBlendMode,t.texture.j);const e=this.localUniforms;e.uniforms.uTransformMatrix=t.groupTransform,e.uniforms.uRound=this.renderer.X|t.X,e.update(),(0,u.V)(t.groupColorAlpha,e.uniforms.uColor,0),this.Dt.execute(this,t)}kt(t){var e,n;return(e=t.L)[n=this.renderer.uid]||(e[n]=new h),t.L[this.renderer.uid].meshData||this.Lt(t)}Lt(t){return t.L[this.renderer.uid].meshData={batched:t.batched,indexSize:0,vertexSize:0},t.L[this.renderer.uid].meshData}Gt(t){var e,n;return(e=t.L)[n=this.renderer.uid]||(e[n]=new h),t.L[this.renderer.uid].batchableMesh||this.Xt(t)}Xt(t){const e=new l.U;return e.renderable=t,e.setTexture(t.$t),e.transform=t.groupTransform,e.roundPixels=this.renderer.X|t.X,t.L[this.renderer.uid].batchableMesh=e,e}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this.Dt.destroy(),this.Dt=null,this.renderer=null}}c.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"mesh"},i.XO.add(c)},6444:(t,e,n)=>{var i=n(8507),s=n(1979),r=n(9408),o=n(4016),a=n(9313),u=n(5611),l=n(4459),h=n(4e3),c=n(6665),f=n(6040),d=n(8475),m=n(5811);const p={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:"\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        "}},v={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:"\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        "}},g={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        "}},x={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        "}};let y,b;class w extends d.M{constructor(t){const e=new m.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new a.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});y??(y=(0,u.v)({name:"sdf-shader",bits:[l.F,(0,h.Yt)(t),p,g,c.b]})),b??(b=(0,u.I)({name:"sdf-shader",bits:[l.a,(0,h.P)(t),v,x,c.m]})),super({glProgram:b,gpuProgram:y,resources:{localUniforms:e,batchSamplers:(0,f.n)(t)}})}}var T=n(1312),C=n(2763);class F extends r.A{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class P{constructor(t){this.o=t}validateRenderable(t){const e=this.Et(t);return this.o.renderPipes.graphics.validateRenderable(e)}addRenderable(t,e){const n=this.Et(t);M(t,n),t._&&(t._=!1,this.Ht(t,n)),this.o.renderPipes.graphics.addRenderable(n,e),n.context.customShader&&this.Wt(t)}updateRenderable(t){const e=this.Et(t);M(t,e),this.o.renderPipes.graphics.updateRenderable(e),e.context.customShader&&this.Wt(t)}Ht(t,e){const{context:n}=e,i=T.c.getFont(t.text,t.tt);n.clear(),"none"!==i.distanceField.type&&(n.customShader||(n.customShader=new w(this.o.limits.maxBatchableTextures)));const s=o.P.graphemeSegmenter(t.text),r=t.tt;let a=i.baseLineOffset;const u=(0,C.Z)(s,r,i,!0),l=r.padding,h=u.scale;let c=u.width,f=u.height+u.offsetY;r.jt&&(c+=r.jt.width/h,f+=r.jt.width/h),n.translate(-t.et.nt*c-l,-t.et.it*f-l).scale(h,h);const d=i.applyFillAsTint?r.qt.color:16777215;let m=i.fontMetrics.fontSize,p=i.lineHeight;r.lineHeight&&(m=r.fontSize/h,p=r.lineHeight/h);let v=(p-m)/2;v-i.baseLineOffset<0&&(v=0);for(let t=0;t<u.lines.length;t++){const e=u.lines[t];for(let t=0;t<e.charPositions.length;t++){const s=e.chars[t],r=i.chars[s];if(r?.texture){const i=r.texture;n.texture(i,d||"black",Math.round(e.charPositions[t]+r.xOffset),Math.round(a+r.yOffset+v),i.orig.width,i.orig.height)}}a+=p}}Et(t){return t.L[this.o.uid]||this.initGpuText(t)}initGpuText(t){const e=new F;return t.L[this.o.uid]=e,this.Ht(t,e),e}Wt(t){const e=this.Et(t).context,n=t.tt.fontFamily,i=s.l.get(`${n}-bitmap`),{a:r,b:o,c:a,d:u}=t.groupTransform,l=Math.sqrt(r*r+o*o),h=Math.sqrt(a*a+u*u),c=(Math.abs(l)+Math.abs(h))/2,f=i.baseRenderedFontSize/t.tt.fontSize,d=c*i.distanceField.range*(1/f);e.customShader.resources.localUniforms.uniforms.uDistance=d}destroy(){this.o=null}}function M(t,e){e.groupTransform=t.groupTransform,e.groupColorAlpha=t.groupColorAlpha,e.groupColor=t.groupColor,e.groupBlendMode=t.groupBlendMode,e.globalDisplayStatus=t.globalDisplayStatus,e.groupTransform=t.groupTransform,e.localDisplayStatus=t.localDisplayStatus,e.groupAlpha=t.groupAlpha,e.X=t.X}P.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"bitmapText"},i.XO.add(P)},6554:(t,e,n)=>{n.d(e,{d:()=>u});var i=n(9113),s=n(3012),r=n(8475),o=n(7547);const a=class t extends r.M{constructor(e){super(e={...t.defaultOptions,...e}),this.enabled=!0,this.St=o.U.for2d(),this.blendMode=e.blendMode,this.padding=e.padding,"boolean"==typeof e.antialias?this.antialias=e.antialias?"on":"off":this.antialias=e.antialias,this.resolution=e.resolution,this.blendRequired=e.blendRequired,this.clipToViewport=e.clipToViewport,this.addResource("uTexture",0,1)}apply(t,e,n,i){t.applyFilter(this,e,n,i)}get blendMode(){return this.St.blendMode}set blendMode(t){this.St.blendMode=t}static from(e){const{gpu:n,gl:r,...o}=e;let a,u;return n&&(a=s.B.from(n)),r&&(u=i.M.from(r)),new t({gpuProgram:a,glProgram:u,...o})}};a.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let u=a},7252:(t,e,n)=>{var i=n(8507),s=n(8734),r=n(4670),o=n(5060);const a=class t extends o.u{constructor(...t){super({});let e=t[0]??{};"number"==typeof e&&((0,r.t6)(r.lj,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),e={width:e,height:t[1],verticesX:t[2],verticesY:t[3]}),this.build(e)}build(e){e={...t.defaultOptions,...e},this.verticesX=this.verticesX??e.verticesX,this.verticesY=this.verticesY??e.verticesY,this.width=this.width??e.width,this.height=this.height??e.height;const n=this.verticesX*this.verticesY,i=[],s=[],r=[],o=this.verticesX-1,a=this.verticesY-1,u=this.width/o,l=this.height/a;for(let t=0;t<n;t++){const e=t%this.verticesX,n=t/this.verticesX|0;i.push(e*u,n*l),s.push(e/o,n/a)}const h=o*a;for(let t=0;t<h;t++){const e=t%o,n=t/o|0,i=n*this.verticesX+e,s=n*this.verticesX+e+1,a=(n+1)*this.verticesX+e,u=(n+1)*this.verticesX+e+1;r.push(i,s,a,s,u,a)}this.buffers[0].data=new Float32Array(i),this.buffers[1].data=new Float32Array(s),this.indexBuffer.data=new Uint32Array(r),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};a.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let u=a;const l=class t extends u{constructor(e={}){super({width:(e={...t.defaultOptions,...e}).width,height:e.height,verticesX:4,verticesY:4}),this.update(e)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this.Kt=t.originalWidth??this.Kt,this.Qt=t.originalHeight??this.Qt,this.Jt=t.leftWidth??this.Jt,this.Nt=t.rightWidth??this.Nt,this.Zt=t.topHeight??this.Zt,this.te=t.bottomHeight??this.te,this.ee=t.anchor?.x,this.ne=t.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,{width:e,height:n,Jt:i,Nt:s,Zt:r,te:o,ee:a,ne:u}=this,l=i+s,h=e>l?1:e/l,c=r+o,f=n>c?1:n/c,d=Math.min(h,f),m=a*e,p=u*n;t[0]=t[8]=t[16]=t[24]=-m,t[2]=t[10]=t[18]=t[26]=i*d-m,t[4]=t[12]=t[20]=t[28]=e-s*d-m,t[6]=t[14]=t[22]=t[30]=e-m,t[1]=t[3]=t[5]=t[7]=-p,t[9]=t[11]=t[13]=t[15]=r*d-p,t[17]=t[19]=t[21]=t[23]=n-o*d-p,t[25]=t[27]=t[29]=t[31]=n-p,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this.Kt,n=1/this.Qt;t[2]=t[10]=t[18]=t[26]=e*this.Jt,t[9]=t[11]=t[13]=t[15]=n*this.Zt,t[4]=t[12]=t[20]=t[28]=1-e*this.Nt,t[17]=t[19]=t[21]=t[23]=1-n*this.te,this.getBuffer("aUV").update()}};l.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let h=l;class c extends s.U{constructor(){super(),this.geometry=new h}destroy(){this.geometry.destroy()}}class f{constructor(t){this.o=t}addRenderable(t,e){const n=this.ie(t);t.didViewUpdate&&this.se(t,n),this.o.renderPipes.batch.addToBatch(n,e)}updateRenderable(t){const e=this.ie(t);t.didViewUpdate&&this.se(t,e),e.D.updateElement(e)}validateRenderable(t){const e=this.ie(t);return!e.D.checkAndUpdateTexture(e,t.$t)}se(t,e){e.geometry.update(t),e.setTexture(t.$t)}ie(t){return t.L[this.o.uid]||this.re(t)}re(t){const e=t.L[this.o.uid]=new c,n=e;return n.renderable=t,n.transform=t.groupTransform,n.texture=t.$t,n.roundPixels=this.o.X|t.X,t.didViewUpdate||this.se(t,n),e}destroy(){this.o=null}}f.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"nineSliceSprite"},i.XO.add(f)},7547:(t,e,n)=>{n.d(e,{U:()=>r});const i={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},s=class t{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(t){!!(1&this.data)!==t&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(t){!!(2&this.data)!==t&&(this.data^=2)}set cullMode(t){"none"!==t?(this.culling=!0,this.clockwiseFrontFace="front"===t):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(t){!!(4&this.data)!==t&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(t){!!(8&this.data)!==t&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(t){!!(32&this.data)!==t&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(t){!!(16&this.data)!==t&&(this.data^=16)}get blendMode(){return this.oe}set blendMode(t){this.blend="none"!==t,this.oe=t,this.ae=i[t]||0}get polygonOffset(){return this.ue}set polygonOffset(t){this.offsets=!!t,this.ue=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new t;return e.depthTest=!1,e.blend=!0,e}};s.default2d=s.for2d();let r=s},8422:(t,e,n)=>{n.d(e,{K:()=>i});class i{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this.le=0,this.D=null,this.he=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this.D=null,this.he=null,this.bounds=null}destroy(){}}},8723:(t,e,n)=>{var i=n(8507),s=n(8639),r=n(7547),o=n(5099),a=n(2760),u=n(8734),l=n(5060),h=n(9313),c=n(5611),f=n(2067),d=n(6665),m=n(8475),p=n(5811),v=n(5589);const g={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},x={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        "}};let y,b;class w extends m.M{constructor(){y??(y=(0,c.v)({name:"tiling-sprite-shader",bits:[f.Ls,g,d.b]})),b??(b=(0,c.I)({name:"tiling-sprite-shader",bits:[f.mA,x,d.m]}));const t=new p.k({uMapCoord:{value:new h.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new h.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:b,gpuProgram:y,resources:{localUniforms:new p.k({uTransformMatrix:{value:new h.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:t,uTexture:v.g.EMPTY.source,uSampler:v.g.EMPTY.source.style}})}updateUniforms(t,e,n,i,s,r){const o=this.resources.tilingUniforms,a=r.width,u=r.height,l=r.textureMatrix,h=o.uniforms.uTextureTransform;h.set(n.a*a/t,n.b*a/e,n.c*u/t,n.d*u/e,n.tx/t,n.ty/e),h.invert(),o.uniforms.uMapCoord=l.mapCoord,o.uniforms.uClampFrame=l.uClampFrame,o.uniforms.uClampOffset=l.uClampOffset,o.uniforms.uTextureTransform=h,o.uniforms.uSizeAnchor[0]=t,o.uniforms.uSizeAnchor[1]=e,o.uniforms.uSizeAnchor[2]=i,o.uniforms.uSizeAnchor[3]=s,r&&(this.resources.uTexture=r.source,this.resources.uSampler=r.source.style)}}class T extends l.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const C=new T;class F{constructor(){this.canBatch=!0,this.geometry=new l.u({indices:C.indices.slice(),positions:C.positions.slice(),uvs:C.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class P{constructor(t){this.St=r.U.default2d,this.o=t}validateRenderable(t){const e=this.ce(t),n=e.canBatch;this.fe(t);const i=e.canBatch;if(i&&i===n){const{batchableMesh:n}=e;return!n.D.checkAndUpdateTexture(n,t.texture)}return n!==i}addRenderable(t,e){const n=this.o.renderPipes.batch;this.fe(t);const i=this.ce(t),{geometry:s,canBatch:r}=i;if(r){i.batchableMesh||(i.batchableMesh=new u.U);const r=i.batchableMesh;t.didViewUpdate&&(this.de(t),r.geometry=s,r.renderable=t,r.transform=t.groupTransform,r.setTexture(t.$t)),r.roundPixels=this.o.X|t.X,n.addToBatch(r,e)}else n.break(e),i.shader||(i.shader=new w),this.updateRenderable(t),e.add(t)}execute(t){const{shader:e}=this.ce(t);e.groups[0]=this.o.globalUniforms.bindGroup;const n=e.resources.localUniforms.uniforms;n.uTransformMatrix=t.groupTransform,n.uRound=this.o.X|t.X,(0,a.V)(t.groupColorAlpha,n.uColor,0),this.St.blendMode=(0,s.i)(t.groupBlendMode,t.texture.j),this.o.encoder.draw({geometry:C,shader:e,state:this.St})}updateRenderable(t){const e=this.ce(t),{canBatch:n}=e;if(n){const{batchableMesh:n}=e;t.didViewUpdate&&this.de(t),n.D.updateElement(n)}else if(t.didViewUpdate){const{shader:n}=e;n.updateUniforms(t.width,t.height,t.me.matrix,t.anchor.x,t.anchor.y,t.texture)}}ce(t){return t.L[this.o.uid]||this.pe(t)}pe(t){const e=new F;return e.renderable=t,t.L[this.o.uid]=e,e}de(t){const e=this.ce(t),{geometry:n}=e,i=t.texture.source.style;"repeat"!==i.addressMode&&(i.addressMode="repeat",i.update()),function(t,e){const n=t.texture,i=n.frame.width,s=n.frame.height;let r=0,o=0;t.applyAnchorToTexture&&(r=t.anchor.x,o=t.anchor.y),e[0]=e[6]=-r,e[2]=e[4]=1-r,e[1]=e[3]=-o,e[5]=e[7]=1-o;const a=h.u.shared;a.copyFrom(t.me.matrix),a.tx/=t.width,a.ty/=t.height,a.invert(),a.scale(t.width/i,t.height/s),function(t,e,n,i){let s=0;const r=t.length/2,o=i.a,a=i.b,u=i.c,l=i.d,h=i.tx,c=i.ty;for(n*=2;s<r;){const e=t[n],i=t[n+1];t[n]=o*e+u*i+h,t[n+1]=a*e+l*i+c,n+=2,s++}}(e,0,0,a)}(t,n.uvs),function(t,e){const n=t.anchor.x,i=t.anchor.y;e[0]=-n*t.width,e[1]=-i*t.height,e[2]=(1-n)*t.width,e[3]=-i*t.height,e[4]=(1-n)*t.width,e[5]=(1-i)*t.height,e[6]=-n*t.width,e[7]=(1-i)*t.height}(t,n.positions)}destroy(){this.o=null}fe(t){const e=this.ce(t),n=t.texture;let i=!0;return this.o.type===o.W.WEBGL&&(i=this.o.context.supports.nonPowOf2wrapping),e.canBatch=n.textureMatrix.isSimple&&(i||n.source.isPowerOfTwo),e.canBatch}}P.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"tilingSprite"},i.XO.add(P)},8734:(t,e,n)=>{n.d(e,{U:()=>i});class i{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this.D=null,this.he=null,this.It=-1,this.ve=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this.ge||this.geometry.topology}set topology(t){this.ge=t}reset(){this.renderable=null,this.texture=null,this.D=null,this.he=null,this.geometry=null,this.ve=-1,this.It=-1}setTexture(t){this.texture!==t&&(this.texture=t,this.It=-1)}get uvs(){const t=this.geometry.getBuffer("aUV"),e=t.data;let n=e;const i=this.texture.textureMatrix;return i.isSimple||(n=this.xe,this.It===i.ye&&this.ve===t.ye||((!n||n.length<e.length)&&(n=this.xe=new Float32Array(e.length)),this.It=i.ye,this.ve=t.ye,i.multiplyUvs(e,n))),n}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},8928:(t,e,n)=>{var i=n(8507),s=n(6302),r=n(7547),o=n(8655),a=n(2760),u=n(6954);class l{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(t=>{o.Z.return(t)}),this.batches.length=0}}class h{constructor(t,e){this.state=r.U.for2d(),this.renderer=t,this.Dt=e,this.renderer.runners.contextChange.add(this)}contextChange(){this.Dt.contextChange(this.renderer)}validateRenderable(t){const e=t.context,n=!!t.L,i=this.renderer.graphicsContext.updateGpuContext(e);return!(!i.isBatchable&&n===i.isBatchable)}addRenderable(t,e){const n=this.renderer.graphicsContext.updateGpuContext(t.context);t.didViewUpdate&&this.be(t),n.isBatchable?this.we(t,e):(this.renderer.renderPipes.batch.break(e),e.add(t))}updateRenderable(t){const e=this.Te(t).batches;for(let t=0;t<e.length;t++){const n=e[t];n.D.updateElement(n)}}execute(t){if(!t.isRenderable)return;const e=this.renderer,n=t.context;if(!e.graphicsContext.getGpuContext(n).batches.length)return;const i=n.customShader||this.Dt.shader;this.state.blendMode=t.groupBlendMode;const s=i.resources.localUniforms.uniforms;s.uTransformMatrix=t.groupTransform,s.uRound=e.X|t.X,(0,a.V)(t.groupColorAlpha,s.uColor,0),this.Dt.execute(this,t)}be(t){const e=this.Te(t),n=this.renderer.graphicsContext.updateGpuContext(t.context);e.destroy(),n.isBatchable&&this.Ce(t,e)}we(t,e){const n=this.renderer.renderPipes.batch,i=this.Te(t).batches;for(let t=0;t<i.length;t++){const s=i[t];n.addToBatch(s,e)}}Te(t){return t.L[this.renderer.uid]||this.Fe(t)}Fe(t){const e=new l;return t.L[this.renderer.uid]=e,e}Ce(t,e){const n=t.context,i=this.renderer.graphicsContext.getGpuContext(n),s=this.renderer.X|t.X;e.batches=i.batches.map(e=>{const n=o.Z.get(u.G);return e.copyTo(n),n.renderable=t,n.roundPixels=s,n})}destroy(){this.renderer=null,this.Dt.destroy(),this.Dt=null,this.state=null}}h.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"graphics"},i.XO.add(h),i.XO.add(s.GH)},9305:(t,e,n)=>{var i=n(8507);class s{execute(t,e){const n=t.state,i=t.renderer,s=e.shader||t.defaultShader;s.resources.uTexture=e.texture.j,s.resources.uniforms=t.localUniforms;const r=i.gl,o=t.getBuffers(e);i.shader.bind(s),i.state.set(n),i.geometry.bind(o.geometry,s.glProgram);const a=2===o.geometry.indexBuffer.data.BYTES_PER_ELEMENT?r.UNSIGNED_SHORT:r.UNSIGNED_INT;r.drawElements(r.TRIANGLES,6*e.particleChildren.length,a,0)}}var r=n(9313),o=n(5811),a=n(8639),u=n(7547),l=n(2760),h=n(949),c=n(1132),f=n(6011),d=n(8306),m=n(1460);function p(t,e=null){const n=6*t;if(n>65535?e||(e=new Uint32Array(n)):e||(e=new Uint16Array(n)),e.length!==n)throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`);for(let t=0,i=0;t<n;t+=6,i+=4)e[t+0]=i+0,e[t+1]=i+1,e[t+2]=i+2,e[t+3]=i+0,e[t+4]=i+2,e[t+5]=i+3;return e}function v(t,e){const n=[];n.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            ");let i=0;for(const s in t){const r=t[s];e===r.dynamic&&(n.push(`offset = index + ${i}`),n.push(r.code),i+=(0,d.m)(r.format).stride/4)}n.push("\n            index += stride * 4;\n        }\n    "),n.unshift(`\n        var stride = ${i};\n    `);const s=n.join("\n");return new Function("ps","f32v","u32v",s)}class g{constructor(t){this.Pe=0,this.Me={};const e=this.Pe=t.size??1e3,n=t.properties;let i=0,s=0;for(const t in n){const e=n[t],r=(0,d.m)(e.format);e.dynamic?s+=r.stride:i+=r.stride}this.Re=s/4,this.Ue=i/4,this.staticAttributeBuffer=new m.u(4*e*i),this.dynamicAttributeBuffer=new m.u(4*e*s),this.indexBuffer=p(e);const r=new f.V;let o=0,a=0;this.Se=new h.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:c.S.VERTEX|c.S.COPY_DST}),this._e=new h.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:c.S.VERTEX|c.S.COPY_DST});for(const t in n){const e=n[t],i=(0,d.m)(e.format);e.dynamic?(r.addAttribute(e.attributeName,{buffer:this._e,stride:4*this.Re,offset:4*o,format:e.format}),o+=i.size):(r.addAttribute(e.attributeName,{buffer:this.Se,stride:4*this.Ue,offset:4*a,format:e.format}),a+=i.size)}r.addIndex(this.indexBuffer);const u=this.getParticleUpdate(n);this.Ae=u.dynamicUpdate,this.ze=u.staticUpdate,this.geometry=r}getParticleUpdate(t){const e=function(t){const e=[];for(const n in t){const i=t[n];e.push(n,i.code,i.dynamic?"d":"s")}return e.join("_")}(t);return this.Me[e]||(this.Me[e]=this.generateParticleUpdate(t)),this.Me[e]}generateParticleUpdate(t){return function(t){return{dynamicUpdate:v(t,!0),staticUpdate:v(t,!1)}}(t)}update(t,e){t.length>this.Pe&&(e=!0,this.Pe=Math.max(t.length,1.5*this.Pe|0),this.staticAttributeBuffer=new m.u(this.Pe*this.Ue*4*4),this.dynamicAttributeBuffer=new m.u(this.Pe*this.Re*4*4),this.indexBuffer=p(this.Pe),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const n=this.dynamicAttributeBuffer;if(this.Ae(t,n.float32View,n.uint32View),this._e.setDataWithSize(this.dynamicAttributeBuffer.float32View,t.length*this.Re*4,!0),e){const e=this.staticAttributeBuffer;this.ze(t,e.float32View,e.uint32View),this.Se.setDataWithSize(e.float32View,t.length*this.Ue*4,!0)}}destroy(){this.Se.destroy(),this._e.destroy(),this.geometry.destroy()}}var x=n(2577),y=n(9113),b=n(3012),w=n(8475),T=n(5589),C=n(218),F="\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class P extends w.M{constructor(){super({glProgram:y.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:b.B.from({fragment:{source:F,entryPoint:"mainFragment"},vertex:{source:F,entryPoint:"mainVertex"}}),resources:{uTexture:T.g.WHITE.source,uSampler:new C.n({}),uniforms:{uTranslationMatrix:{value:new r.u,type:"mat3x3<f32>"},uColor:{value:new x.Q(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class M{constructor(t,e){this.state=u.U.for2d(),this.localUniforms=new o.k({uTranslationMatrix:{value:new r.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=t,this.adaptor=e,this.defaultShader=new P,this.state=u.U.for2d()}validateRenderable(t){return!1}addRenderable(t,e){this.renderer.renderPipes.batch.break(e),e.add(t)}getBuffers(t){return t.L[this.renderer.uid]||this.Oe(t)}Oe(t){return t.L[this.renderer.uid]=new g({size:t.particleChildren.length,properties:t.Ve}),t.L[this.renderer.uid]}updateRenderable(t){}execute(t){const e=t.particleChildren;if(0===e.length)return;const n=this.renderer,i=this.getBuffers(t);t.texture||(t.texture=e[0].texture);const s=this.state;i.update(e,t.De),t.De=!1,s.blendMode=(0,a.i)(t.blendMode,t.texture.j);const r=this.localUniforms.uniforms,o=r.uTranslationMatrix;t.worldTransform.copyTo(o),o.prepend(n.globalUniforms.globalUniformData.projectionMatrix),r.uResolution=n.globalUniforms.globalUniformData.resolution,r.uRound=n.X|t.X,(0,l.V)(t.groupColorAlpha,r.uColor,0),this.adaptor.execute(this,t)}destroy(){this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class R extends M{constructor(t){super(t,new s)}}R.extension={type:[i.Ag.WebGLPipes],name:"particle"};class U{execute(t,e){const n=t.renderer,i=e.shader||t.defaultShader;i.groups[0]=n.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms,!0),i.groups[1]=n.texture.getTextureBindGroup(e.texture);const s=t.state,r=t.getBuffers(e);n.encoder.draw({geometry:r.geometry,shader:e.shader||t.defaultShader,state:s,size:6*e.particleChildren.length})}}class S extends M{constructor(t){super(t,new U)}}S.extension={type:[i.Ag.WebGPUPipes],name:"particle"},i.XO.add(R),i.XO.add(S)}}]);